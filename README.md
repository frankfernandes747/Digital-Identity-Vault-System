# Digital Identity Vault

A secure web application for storing and managing personal identity documents with role-based access control.

## Features

- **User Authentication**: Secure email/password authentication with Supabase
- **Document Management**: Upload and store documents in Supabase Storage
- **Metadata Tracking**: Store document metadata including expiry dates and categories
- **Expiry Alerts**: Easily identify documents that are approaching their expiry dates
- **Admin Approval Workflow**: Documents require admin approval before becoming visible
- **Secure Sharing**: Generate time-limited share links for documents
- **Role-Based Access**: Different views and permissions for users and administrators

## Technology Stack

- [Next.js 15](https://nextjs.org/) with App Router and TypeScript
- [Supabase](https://supabase.io/) for authentication and database
- [Tailwind CSS](https://tailwindcss.com/) for styling
- [Lucide React](https://lucide.dev/) for icons
- [React Hook Form](https://react-hook-form.com/) for form handling
- [Zod](https://zod.dev/) for validation

## Getting Started

### Prerequisites

- Node.js 18 or higher
- A Supabase project (free tier)

### Setup

1. **Install dependencies**

```bash
npm install
```

2. **Environment Variables**

Create a `.env.local` file in the project root with the following variables:

```env
NEXT_PUBLIC_SUPABASE_URL=your-supabase-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-supabase-service-role-key
NEXT_PUBLIC_SITE_URL=http://localhost:3000
```

3. **Supabase Configuration**

In your Supabase project, configure the following:

- Enable Email/Password authentication in the Auth settings
- Create a Storage bucket named `documents`
- Create the following database tables by running these SQL commands in the Supabase SQL editor:

**Profiles Table:**
```sql
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  full_name text,
  email text not null,
  role text check (role in ('user', 'admin')) default 'user',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
```

**Categories Table:**
```sql
create table categories (
  id bigint generated by default as identity primary key,
  name text not null
);
```

**Documents Table:**
```sql
create table documents (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  file_name text not null,
  file_url text not null,
  document_type text,
  tags text[],
  expiry_date date,
  status text check (status in ('Pending', 'Approved', 'Rejected')) default 'Pending',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  category_id bigint references categories(id)
);
```

**Shared Links Table:**
```sql
create table shared_links (
  id uuid default gen_random_uuid() primary key,
  document_id uuid references documents(id) on delete cascade not null,
  share_token uuid not null unique,
  expires_at timestamp with time zone not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
```

**Enable Row Level Security (RLS) on all tables:**
```sql
alter table profiles enable row level security;
alter table categories enable row level security;
alter table documents enable row level security;
alter table shared_links enable row level security;
```

**RLS Policies:**
```sql
-- Profiles policies
create policy "Users can view their own profile" on profiles for select using (auth.uid() = id);
create policy "Users can update their own profile" on profiles for update using (auth.uid() = id);
create policy "Admins can view all profiles" on profiles for select using (role = 'admin');

-- Categories policies
create policy "Categories are viewable by everyone" on categories for select using (true);

-- Documents policies
create policy "Users can view their own documents" on documents for select using (auth.uid() = user_id);
create policy "Users can insert their own documents" on documents for insert with check (auth.uid() = user_id);
create policy "Users can update their own documents" on documents for update using (auth.uid() = user_id);
create policy "Users can delete their own documents" on documents for delete using (auth.uid() = user_id);
create policy "Admins can view all documents" on documents for select using (exists (select 1 from profiles where id = auth.uid() and role = 'admin'));
create policy "Admins can update document status" on documents for update using (exists (select 1 from profiles where id = auth.uid() and role = 'admin'));

-- Shared Links policies
create policy "Shared links are viewable by token" on shared_links for select using (share_token = share_token);
```

**Sample Data (Optional):**
```sql
-- Insert some sample categories
insert into categories (name) values 
  ('Passport'), 
  ('Driver License'), 
  ('ID Card'), 
  ('Visa'), 
  ('Certificate');
```

4. **Run the Application**

```bash
npm run dev
```

Visit [http://localhost:3000](http://localhost:3000) in your browser.


## Project Structure

```
src/
├── app/                  # Next.js App Router pages
│   ├── auth/             # Authentication (login/register)
│   ├── dashboard/        # User dashboard
│   ├── upload/           # Document upload interface
│   ├── admin/            # Admin approval dashboard
│   ├── profile/          # User profile management
│   └── api/              # API routes
├── components/           # Reusable UI components
│   ├── layout/           # Layout components
│   └── ui/               # UI components
├── lib/                  # Utility libraries
│   └── supabase/         # Supabase client configurations
└── utils/                # Helper functions
```

## User Roles

- **User**: Can upload documents, view their own documents, and generate share links
- **Admin**: Can approve documents, view all documents, and manage the system

New users default to the "user" role. To promote a user to admin, update the `role` field in the `profiles` table to "admin" in your Supabase database.

## Security

- All routes are protected with authentication middleware
- Role-based access control is implemented both client-side and server-side
- Share links are time-limited and token-based


## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
